
# other: inside R open dataframe with vd

[loading data](https://www.visidata.org/docs/loading/)

``` 
devtools::install_github('paulklemm/rvisidata')
vd(iris)
``` 

# visidata: multiline string desteği 20200514  id=g_10937

[VisiData Architecture for Developers — VisiData 0.91 documentation](https://forked-visidata.readthedocs.io/en/latest/architecture.html)

> Multi-line docstrings are surrounded by three single quotes ('''...''').

## opt01: update visidata first:

### update visidata

opt01: using conda

``` 
pip3 uninstall visidata
conda env list
source activate py37
conda config --add channels conda-forge
conda install visidata
conda update visidata

``` 

opt02: pipx

https://pipxproject.github.io/pipx/

``` 
brew install pipx
pipx ensurepath
pipx completions
``` 

https://www.visidata.org/install/#pip3

``` 
pipx install visidata

### Upgrade to the latest stable version
pipx upgrade visidata

### Add packages to VisiData's environment
pipx inject visidata <package>

### Install a specific version of VisiData
pipx install git+https://github.com/saulpw/visidata@v2.-2.1
``` 

## opt02: kendi tsv dosyalarınla deneme yap

Check `~/projects/study/code/ex/study_visidata/e01/t02.tsv`

``` 
vd t02.tsv
``` 

Sonuç

- quote `""` içindeki newline karakterleri yeni satıra geçiyor
- tek çözüm: çok uzun hücrelerde `v` ile wrap yapmak

## opt06: dplyr'da bu hücreleri join et Þ character ile

newline karakterlerini hex karakter `Þ` ile değiştir

[python - How to store strings in CSV with new line characters? - Data Science Stack Exchange](https://datascience.stackexchange.com/questions/35868/how-to-store-strings-in-csv-with-new-line-characters)

``` 
library(dplyr)
library(readr)
d0 = read_tsv("t02.tsv") 
d1 = d0 %>%
	mutate(col2 = stringr::str_replace(col2, "\\n", "Þ"))
``` 

opt02: sed ile yap

https://backreference.org/2009/12/23/how-to-match-newlines-in-sed/

``` 
sed -e 's/\n/Þ/g' t02.tsv > t03.tsv
``` 

# error: fzf problemi: tab completion kaybolmuş 20200514 


