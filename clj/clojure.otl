ref
	~/projects/study/clj/refcard_clojure.otl
index
	ref
		datomic.otl <url:file:///~/projects/study/clj/datomic.otl#r=g12849>
		~/projects/study/clj/fulcro.otl
	anki clojure
		~/projects/study/clj/anki_clojure_from_excel.tsv
		~/projects/study/clj/anki_clojure.tsv
	projects id=g12848
		ex06 ~/projects/study/clj/ex/study_clojure/ex06/ex06.iml
			~/projects/study/clj/ex/study_clojure/ex06/src/ex_kimh.clj
		datalog-01 /Users/mertnuhoglu/projects/study/clj/ex/study_datomic/datalog-01/deps.edn
			~/projects/study/clj/ex/study_datomic/datalog-01/src/mertnuhoglu/datomic/datomic_01.clj
		/Users/mertnuhoglu/projects/study/clj/ex/fulcro/fulcro.iml
	rfc quickstart id=g12853
		projects <url:file:///~/projects/study/clj/clojure.otl#r=g12848>
		datomic <url:file:///~/projects/study/clj/clojure.otl#r=g12850>
		Setup a new project  <url:file:///~/projects/study/clj/clojure.otl#r=g11946>
		Run REPL <url:file:///~/projects/study/clj/clojure.otl#r=g12068>
		Run a clojure script/function/app <url:file:///~/projects/study/clj/clojure.otl#r=g12108>
		idioms - kendime göre özetler <url:file:///~/projects/study/clj/clojure.otl#r=g12080>
		Weird Characters <url:file:///~/projects/study/clj/book_clojure_documentation.md#r=g11401>
		editors clojure <url:file:///~/projects/study/clj/clojure.otl#r=g12360>
@questions - clojure id=g12396
	slack vs. yerine stackoverflow'da soruları sormak, bulunabilirlik açısından daha iyi olmaz mı?
clojure
	authors id=g11837
		Rich Hickey - Clojure
		David Nolen - ClojureScript, core.logic, om next
		unprompt - Meander
		Brian Will - Intro to Clojure
		Reeves - polymorphism
		Jimmy Miller - Meander
		Nathan Marz - Specter
		Tony Kay - Fulcro
		Michiel Borkent - babashka, jet
		Timothy Baldridge - clojure tutorials, pivotshare videos
		William Byrd - miniKanren
		Daniel Friedman - miniKanren
		Gerald Sussman - SICP
		Sean Corfield - rebl
	editors clojure id=g12360
		sexp editing id=g12869
			ref
				sexp_editing.otl ~/projects/study/clj/sexp_editing.otl
				Cheatsheet cleverparens vim-sexp <url:file:///~/projects/study/emacs/smartparens.md#r=g11961>
				smartparens custom mappings <url:file:///~/projects/private_dotfiles/.config/doom/config.el#r=g12112>
				sexp cheatsheet <url:file:///~/projects/study/clj/vim_sexp.md#r=g11971>
		cursive intellij
			ref
				quickstart cursive <url:file:///~/projects/study/clj/cursive.md#r=g11816>
			shortcuts
				Cursive repl eval keybindings <url:file:///~/projects/private_dotfiles/.ideavimrc#r=g12857>
				QuickList Popup keybindings <url:file:///~/projects/private_dotfiles/.ideavimrc#r=g12856>
				| çd       | eval top form  |
				| çe       | eval last form |
				| #e       | actions command bar            |
				| !u       | ç: popup menu prefix           |
				| !up/çp   | popup menus                    |
				| !uj      | clojure popup menu             |
				| !uç/çç   | popup general menu             |
				| !un/çn   | popup next menu                |
				| !ue/çt   | popup structural editing menu  |
				| !u SPC   | popup move menu                |
		vim conjure
			conjure
				Index: Clojure in Vim <url:file:///~/projects/study/clj/clojure_in_vim.md#r=g11843>
				conjure <url:file:///~/projects/vim_repos/my-vim-custom/plugin/my-vim-custom.vim#r=g12847>
				shortcuts
					[`,` yerine SPC m konulacak]
					| SPC m     | prefix instead of comma ,         |
					| ,vv       | open log buffer vertical          |
					| ,ee       | eval current form                 |
					| ,eb       | eval buffer                       |
					| ,em[mark] | eval form under given `mark`      |
					| ,ew       | eval word under cursor (peek var) |
					| ,E        | eval visual selection             |
					öneksiz düz kısayollar:
					| çc | eval_comment_current_form |
					| çe | eval_current_form         |
					| çr | eval_root_form            |
					| K  | look up documentation     |
					| gd | go to definition          |
				temel kullanım
					clojure -M:repl/rebel-nrepl
					ConjureConnect [port]
					let g:conjure#mapping#prefix = " m"
					| ,ed     | evaluate inner expression       | eval (current-form)    |
					lua require('conjure.eval')['current-form']()
					lua require('conjure.eval')['root-form']()
					nnoremap <leader>mec :call ConjureEvalToComment()<cr>
			fireplace.md
				Quickref fireplace.vim <url:file:///~/projects/study/clj/fireplace.md#r=g12014>
					| ]d     | Source                     |
					| gf     | go to source of namespace  |
					| cmm    | Macroexpand innermost form |
					| :Eval  | eval current form          |
					| :Eval% | eval file                  |
			vim_sexp.md 
				sexp editing <url:file:///~/projects/study/clj/clojure.otl#r=g12869>
			Disable linter: <url:file:///~/projects/study/clj/clojure_in_vim.md#r=g11965>
				call lsp#disable_diagnostics_for_buffer()
		emacs
			doom
				Doom Refcard  <url:file:///~/projects/study/emacs/doom.md#r=g12039>
				Doom Cider Refcard <url:file:///~/projects/study/emacs/doom.md#r=g12074>
			spacemacs
				spacemacs refcard <url:file:///~/projects/study/emacs/spacemacs.md#r=g11015>
					| SPC SPC   | list and search all commands | M-x                         |
					| SPC ?     | search for key bindings      | show keybindings            |
					| C-h k     | search for key binding       | describe-key                |
					| SPC h d f | help on function             | describe-function           |
					| SPC h SPC | list layers                  |                             |
					| SPC f e d | open ~/.spacemacs            | find-dotfile                |
					| SPC f e R | reload .spacemacs            |                             |
					| SPC f r   | file recent                  | counsel-recentf             |
					| SPC q r   | restart emacs                | restart-emacs               |
					| SPC w d   | buffer kill                  | delete-window               |
					| SPC m     | cider menu                   | ,                           |
					| '         | start REPL                   | cider-jack-in               |
					| e         | eval menu                    |                             |
					| e f       | eval expression inline       | cider-eval-defun-at-point   |
					| e c       | eval expression as comment   | cider-eval-defun-to-comment |
					| s a       | cider-switch-to-repl-buffer  |                             |
					| SPC a	r   | open ranger                  |
					| C-x t 2   | tab-bar-new-tab              |
					| gt gT     | tab-next                     |
				Cheatsheet cleverparens vim-sexp <url:file:///~/projects/study/emacs/smartparens.md#r=g11961>
					ref_ex: ~/projects/study/emacs/ex/smartparens/e01/cleverparens_commands.clj
			multiple emacs: chemacs
				Multiple Emacs Setups/Installations in Osx <url:file:///~/projects/study/emacs/emacs.md#r=g12029>
				~/projects/private_dotfiles/.config/chemacs/profiles.el
				emacs --with-profile default
		paredit vim-sexp smartparens cleverparens
			sexp_editing.otl ~/projects/study/clj/sexp_editing.otl
	trainings
		https://lambdaisland.com/episodes
		https://purelyfunctional.tv/browse/
		https://tbaldridge.pivotshare.com/
	language
		Destructuring
			destructuring <url:file:///~/projects/study/clj/ex/study_clojure/ex06/src/destructuring.clj#r=g11408>
			Destructuring <url:file:///~/projects/study/clj/book_clojure_practicalli.md#r=g11407>
		Weird Characters <url:file:///~/projects/study/clj/book_clojure_documentation.md#r=g11401>
			ref: ~/projects/study/clj/ex/study_clojure/ex06/src/weird_characters.clj
	libraries
		clojure.repl help functions <url:file:///~/projects/study/clj/book_essential_reference_borgatti.md#r=g11959>
			ref_ex: ~/projects/study/clj/ex/study_clojure/ex06/src/help_functions.clj
howto problems
	debugging
		dirac: chrome devtools plugin id=g12454
			kurulum:
				[dirac/cli.md at master · binaryage/dirac](https://github.com/binaryage/dirac/blob/master/docs/cli.md#how-does-dirac-locate-chromium-executable-on-my-machine)
				ln -s "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" link
			kullanım:
				cli: dirac
					dirac ile chrome başlat
				chrome içinden localhost:8000 gibi web uygulamasını aç
				console'a gir, `^,` ile cljs repl'ını başlat
			breakpoint ekleme:
				[(743) Clojurescript and Dirac workflow - YouTube](https://www.youtube.com/watch?v=DDmUop6XlmQ)
				kodun içine (js-debugger) koy
				uygulamayı çalıştırdığında dirac orada durur
		spacemacs cider debugging
			Debugging cider <url:file:///~/projects/study/clj/cider.md#r=g11969>
				| , d b | cider-debug-defun-at-point         |
				| , e f | cider-eval-defun-at-point          |
				| C-z   | disable evil mode during debugging |
		Debug Functions <url:file:///~/projects/study/clj/book_essential_reference_borgatti.md#r=g11960>
			ref_ex: ~/projects/study/clj/ex/study_clojure/ex06/src/debug_functions.clj
				hashp for tracing <url:file:///~/projects/study/clj/ex/study_clojure/ex06/src/debug_functions.clj#r=g11988>
				cider debugging example <url:file:///~/projects/study/clj/ex/study_clojure/ex06/src/debug_functions.clj#r=g11970>
	deps.edn
		find-deps ile search library
			ref: find-deps - fuzzy search Maven & Clojars and add deps to deps.edn <url:/Users/mertnuhoglu/projects/private_dotfiles/.config/clojure/deps.edn#tn=;; find-deps - fuzzy search>
			clojure -M:project/find-deps http-kit
	repl'a mevcut clj namespace'ini yüklemek
		cursive: load-file veya Send file to REPL
		repl: 
			(require '[my-namespace])
				(require '[clojure.edn :as edn])
				(require '[clojure.java.io :refer [reader]])
			(in-ns 'my-namespace)
	Setup a new project  id=g11946
		New Clojure Project <url:deps_cli.md#r=g11941>
			clojure -X:project/new :name main/project01
				; src/main klasörünü oluşturur proje dizininde
				; project01/src/main
			clojure -X:project/new :name mert/project-01
			clojure -X:project/new :name mertnuhoglu/project-01
			cd project-01
	Run REPL id=g12068
		ref
			~/projects/study/clj/rebl_reveal_portal_repl.otl
		multiple repls together: id=g12447
			alias zshrc
				cljreblportal
			rebl+portal
				java15
				clojure -M:lib/cider-nrepl:inspect/rebl15:middleware/nrebl:inspect/portal-cli:repl/rebel-nreply
			reveal+portal
				clojure -M:inspect/reveal:repl/rebel:inspect/portal-cli:repl/rebel-nreply
			rebl+reveal
				clojure -M:lib/cider-nrepl:inspect/rebl15:middleware/nrebl:inspect/reveal
					opens reveal
				clojure -M:inspect/reveal:lib/cider-nrepl:inspect/rebl15:middleware/nrebl
					opens rebl
				main opts
					:inspect/reveal "-m" "vlaaad.reveal" "repl"
					:lib/cider-nrepl
					:inspect/rebl15 "-m" "cognitect.rebl"
					:middleware/nrebl "-m" "nrepl.cmdline"
			rebl+reveal+portal id=g12431
				java15
				clojure -M:inspect/reveal:repl/rebel:inspect/portal-cli:repl/rebel-nreply:lib/cider-nrepl:inspect/rebl15:middleware/nrebl
				(add-tap ((requiring-resolve 'vlaaad.reveal/ui))) ; reveal açar
				çalışmıyor:
					opt01:
						java15
						clojure -M:lib/cider-nrepl:inspect/rebl15:middleware/nrebl:inspect/portal-cli:repl/rebel-nreply:inspect/reveal:repl/rebel
					opt02:
						clojure -M:inspect/reveal:repl/rebel:inspect/portal-cli:repl/rebel-nreply:lib/cider-nrepl:inspect/rebl15:middleware/nrebl
						(require '[vlaaad.reveal :as reveal])
						(reveal/-main "repl")
		run REBL id=g12422
			Run REBL for nREPL <url:file:///~/projects/study/clj/rebl.md#r=g11934>
				java15
				clojure -M:trace:inspect/reveal-nrepl
				clojure -M:lib/cider-nrepl:inspect/rebl15:middleware/nrebl
				Connect REBL from Emacs Cider <url:file:///~/projects/study/clj/rebl.md#r=g11943>
					SPC SPC cider-connect-clj
				Connect REBL from Intellij Cursive <url:file:///~/projects/study/clj/rebl.md#r=g11944>
					Configurations > Clojure REPL > Remote
					Connection Type: nREPL
					Use standard port file: checked
				Connect REBL from Vim Conjure <url:file:///~/projects/study/clj/rebl.md#r=g11945>
					:ConjureConnect <port>
		nREPL
			nrepl with rebel
				clojure -M:repl/rebel-nrepl
			Reveal with nrepl <url:file:///~/projects/study/clj/reveal_repl.md#r=g11949>
				clojure -M:inspect/reveal-nrepl
			bb nrepl server <url:file:///~/projects/study/clj/babashka_interpreter.md#r=g11958>
				bb --nrepl-server 50500
				lein repl :connect 50500
		rebel
			Run rebel-readline
				clj -M:repl/rebel
		Reveal
			Reveal with rebel-readline <url:file:///~/projects/study/clj/reveal_repl.md#r=g11749>
				clojure -M:inspect/reveal:repl/rebel
				(add-tap ((requiring-resolve 'vlaaad.reveal/ui)))
				(tap> {:a 1 :b 2})
		portal id=g12421
			opt00: hem portal hem nrepl
				clojure -M:inspect/portal-cli:repl/rebel-nrepl
			opt01: çalışıyor
				clojure -M:inspect/portal-cli
				(require '[portal.api :as portal])
			opt02: bozuk
				clojure -M:inspect/portal-web
				(require '[portal.web :as portal])
			ortak:
				(portal/open)
				(portal/tap)
				(tap> {:accounts [{:name "jen" :email "jen@jen.com"} {:name "sara" :email "sara@sara.com"}]})
			opt03: doğrudan main olarak çalıştır
				cat deps.edn | clojure -M:portal/cli edn
			opt03a: doğrudan aliaslar kullan
				cat deps.edn | edn
				cat j01.json | json
	Run a clojure script/function/app id=g12108
		from repl:
			ref: ~/projects/study/clj/book_practicalli_clojure_webapps.md
			(require '[practicalli.p02] :verbose)
			(in-ns 'practicalli.p02)
			(def app-server-instance (-main 8888))
		from conjure/vim:
			ref: ~/projects/study/clj/book_practicalli_clojure_webapps.md
			ConjureConnect
			,eb | eval buffer
			Eval: `(def app-server-instance (-main 8888))`
		from cli: clj
			Run main function <url:file:///~/projects/study/clj/deps_cli.md#r=g12070>
				clj -M -m clj-new-01.clj-new-01
				clojure src/cards/core.clj
			Running functions <url:file:///~/projects/study/clj/deps_cli.md#r=g12071>
				clj -X:my-fn
	require import libraries
		inside code
			ref: ~/projects/study/clj/ex/study_clojure/ex06/src/require_functions.clj
			(require '[clojure.tools.trace :refer [trace, dotrace]])
			(use '[clojure.string :only (split)])
			(ns help_functions
				(:require [clojure.inspector :as ins]))
			(require 'hashp.core)
			(require '[clojure.repl :refer :all])
		require inside repl id=g12420
			(ns ex01
				{:import java.io.File}
				{:require [clojure.java.io :as io]
									[clojure.core.protocols :as p])
		Import source, doc, apropos and other REPL functions <url:file:///~/projects/study/clj/clojure_cli_tools.md#r=g11947>
			(require '[clojure.repl :refer :all])
			ref: ~/projects/study/clj/ex/study_clojure/ex06/src/help_functions.clj
				(pp/print-table [{:a 1 :b 2 :c 3}{:a 4 :b 5 :c 6}])
				(clojure.repl/source map)
				(clojure.repl/doc map)
				(clojure.repl/find-doc "create-context")
				(clojure.repl/apropos "unmount-renderer")
				(clojure.repl/dir help_functions)
				*ns*
				(ns-aliases 'user)
				(ns-publics 'clojure.java.io)
				(all-ns)
	vim
		Show Documentation in Conjure Floating Window <url:clojure_in_vim.md#r=g11957> ,eb > K
	data browser / edn navigation
		ref
			portal <url:file:///~/projects/study/clj/clojure.otl#r=g12421>
idioms - kendime göre özetler id=g12080
	let
		(let [a b
		      c a])
		=> 
			a = b
			c = a
	assoc get update assoc-in get-in update-in
		ref: ~/projects/study/clj/ex/study_clojure/ex06/src/assoc_update.clj
		(assoc request :user user)
			denk: request[[:user]] = user
			denk: request.user = user
		(assoc-in users [1 :age] 44)
		(get-in {:a {:b 1}} [:a :b]) ;;=> 1
		(update-in users [1 :age] inc)
		(update-in {:a {:b {:x 3} :c 1}} [:a :b] dissoc :x)
	->
		(-> request :session :user-id)
		= request[[:session]][[:user-id]]
		= request.session.user-id
	Ring suyu id=g12082
		middleware fonksiyonu tanımlama:
			(defn mw [handler]
				(fn [request]
					...
					(assoc request ...)
					(handler request)))
		mw fonksiyonlarını kullanma:
			(def app (-> handler (mw1) (mw2) ...))
		handler tipi: request -> response
		default değer için or kullanma:
			(or (.getScheme uri) "http")
			(or query params)
		string değerleri keyworde çevirip kullanma:
			let [
				scheme (keyword (or (.getScheme uri) "http"))
				request {:scheme         scheme}
			]
	main default arguments
		ref: ~/projects/study/clj/ex/book_practicalli_clojure_webapps/p01/src/practicalli/p06.clj
		(defn -main
			[& {:keys [ip port]
					:or   {ip   "0.0.0.0"
								 port 8000}}]
		kullanımı:
			(-main :port 8080)
	server initialization in webapps
		(def server (atom nil))
		(defn -main
			(reset! server (server/run-server #'handler {:port port})))
		(defn stop-server []
			(when-not (nil? @server)
				(@server :timeout 100)
				(reset! server nil)))
		kullanımı:
			(-main)
			(stop-server)
topics 
	io - file
		ref
			~/projects/study/clj/ex/study_clojure/ex06/src/io_file.clj
		(edn/read-string (slurp "deps.edn")) ; edn file -> string -> map
		(spit "tmp.txt" "test")
		(slurp "tmp.txt") ;; => "test"
	data structures
		boolean
			(boolean false) ;; => false
			(boolean nil) ;; => false
			(boolean 0) ;; => true
			(boolean []) ;; => true
		string
			; Strings <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11330>
				(str "join " "strings") ;; => "join strings"
				(format "%s %s" "this is" "me") ;; => "this is me"
		numbers
			; Numbers <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11331>
			(/ 4 3) ;; => 4/3
			(* (/ 4 3) 3) ;; => 4N
		lists
			; Lists <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11332>
			'(1 2 3) ;; => (1 2 3)
			(conj '(1 2) 3) ;; => (3 1 2)
			(nth '(3 5 2) 1) ;; => 5
			(count '(5 3)) ;; => 2
		vectors
			; Vectors <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11333>
			[3 2 5] ;; => [3 2 5]
			(conj [4 1] 7) ;; => [4 1 7]
			(nth [3 2] 0) ;; => 3
			(last [2 7 1]) ;; => 1
			(get ["a" "b"] 1) ;; => "b"
		sets
			; Sets <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11334>
			(conj #{1 2 3} 4) ;; => #{1 4 3 2}
			(disj #{1 2 3} 3) ;; => #{1 2}
			(sort #{1 2 3}) ;; => (1 2 3)
			(contains? #{1 2 3} 2) ;; => true
			(clojure.set/subset? #{1 2} #{1 2 3}) ;; => true
			(clojure.set/superset? #{1 2 3} #{1 2}) ;; => true
		maps
			; Maps <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11335>
			{:a 1 :b 2} ;; => {:a 1, :b 2}
			(get {:a 1 :b 2} :a) ;; => 1
			({:a 1 :b 2} :a) ;; => 1
			({:a 1 :b 2} :c "default") ;; => "default"
			(:a {:a 1 :b 2}) ;; => 1
			(assoc {:a 1} :c 3) ;; => {:a 1, :c 3}
			(merge {:a 1} {:c 3}) ;; => {:a 1, :c 3}
			(keys {:a 1 :b 2}) ;; => (:a :b)
			(vals {:a 1 :b 2}) ;; => (1 2)
			(contains? {:a 1 :b 2} :a) ;; => true
			(get-in {:a {:b 3}} [:a :b]) ;; => 3
			; Threading macro to shorten code: <url:book_clojure_practicalli.md#r=g11406>
				(-> {:a {:b 3}}
						:a
						:b)
				;; => 3
	sequences
		sequences
			; Sequences <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11336>
				(seq '(1 2)) ;; => (1 2)
				(seq [1 2]) ;; => (1 2)
				(first [5 2]) ;; => 5
				(second [5 2]) ;; => 2
				(rest [1 2 3]) ;; => (2 3)
				(cons 0 [1 2]) ;; => (0 1 2)
				(concat '(1 2) '(3 4)) ;; => (1 2 3 4)
			;; sect01: shorter seq <url:ex/study_clojure/ex06/src/clojure_ref_sequences.clj#r=g11359>
				(distinct [1 2 3 1]) ;; => (1 2 3)
				(filter even? [1 2 3]) ;; => (2)
				(remove pos? [-1 0 1]) ;; => (-1 0)
				(for [x [0 1 2] :let [y (inc x)] when (even? y)] x) ;; => (1)
				(keep pos? [-1 0 1]) ;; => (false false true)
				(keep-indexed #(if (odd? %1) %2) [:a :b :c]) ;; => (:b)
			;; sect02: longer seq <url:ex/study_clojure/ex06/src/clojure_ref_sequences.clj#r=g11360>
				(cons 1 [2 3]) ;; => (1 2 3)
				(cons 1 '(2 3)) ;; => (1 2 3)
				(concat [1 2] [3 4]) ;; => (1 2 3 4)
				(lazy-cat [1 2] [3 4]) ;; => (1 2 3 4)
				(mapcat reverse [[1 2] [3 4]]) ; foldMap ;; => (2 1 4 3)
				(take 5 (cycle [1 3]))  ; rep ;; => (1 3 1 3 1)
				(interleave [:a :b] [1 2]) ; zip ;; => (:a 1 :b 2)
				(interpose ", " ["ali" "veli"]) ;; => ("ali" ", " "veli")
				(apply str (interpose ", " ["ali" "veli"])) ;; => "ali, veli"
				(str/join ", " ["ali" "veli"]) ;; => "ali, veli"
			;; sect03: head-items missing <url:ex/study_clojure/ex06/src/clojure_ref_sequences.clj#r=g11361>
				(rest [1 2 3]) ;; => (2 3)
				(next [:a :b :c]) ;; => (:b :c)
				(rest [:a]) ;; => ()
				(next [:a]) ;; => nil
				(fnext [1 2 3]) ;; => 2
				(nnext [1 2 3]) ;; => (3)
				(drop 2 [1 2 3]) ;; => (3)
				(drop -1 [1 2 3]) ;; => (1 2 3)
				(drop 5 [1 2 3]) ;; => ()
				(drop-while pos? [1 3 -2 -5 4]) ;; => (-2 -5 4)
				(nthnext [1 2 3] 2) ;; => (3)
			;; sect04: tail-items missing <url:ex/study_clojure/ex06/src/clojure_ref_sequences.clj#r=g11362>
				(take 2 [1 2 3]) ;; => (1 2)
				(take-nth 2 [1 2 3 4 5]) ;; => (1 3 5)
				(take-while pos? [1 2 -1 3]) ;; => (1 2)
				(butlast [1 2 3]) ;; => (1 2)
				(drop-last 2 [1 2 3]) ;; => (1)
			;; sect05: rearrangement of a seq <url:ex/study_clojure/ex06/src/clojure_ref_sequences.clj#r=g11363>
				(flatten [1 [2 3]]) ;; => (1 2 3)
				(reverse [1 2 3]) ;; => (3 2 1)
				(sort [3 1 2]) ;; => (1 2 3)
				(sort-by count ["ali" "x"]) ;; => ("x" "ali")
				(shuffle [1 2 3]) ;; => [1 2 3]
			;; sect06: nested seqs <url:ex/study_clojure/ex06/src/clojure_ref_sequences.clj#r=g11364>
				(split-at 2 [1 2 3 4 5]) ;; => [(1 2) (3 4 5)]
				(split-with pos? [1 2 -1 3]) ;; => [(1 2) (-1 3)]
				(split-with (partial > 2) [1 2 -1 0]) ;; => [(1) (2 -1 0)]
				(partition 2 (range 5)) ;; => ((0 1) (2 3))
				(partition-all 2 (range 5)) ;; => ((0 1) (2 3) (4))
				(partition-by pos? [-1 3 0 -3]) ;; => ((-1) (3) (0 -3))
			;; sect07: partition each item to create a new seq <url:ex/study_clojure/ex06/src/clojure_ref_sequences.clj#r=g11365>
				(map inc [1 2 3]) ;; => (2 3 4)
				(map + [1 2] [3 4]) ;; => (4 6)
				(apply map vector [[:a :b :c] [:d :e :f] [:g :h :i]]) ;; => ([:a :d :g] [:b :e :h] [:c :f :i])
				(pmap inc [1 2 3]) ;; => (2 3 4)
				(mapcat reverse [[1 2] [3 4]]) ; foldMap ;; => (2 1 4 3)
				(for [x [0 1 2] :let [y (inc x)]] y) ;; => (1 2 3)
				(replace [:a :b :c :d :e] [0 3 0]) ;; => [:a :d :a]
				(reductions + [1 2 3]) ;; => (1 3 6)
				(map-indexed #(when (< % 2) (str % %2)) [:a :b :c]) ;;=> ("0:a" "1:b" nil)
				(keep-indexed #(when (< % 2) (str % %2)) [:a :b :c]) ;;=> ("0:a" "1:b")
			;; sect08: extract a specific-numbered item <url:ex/study_clojure/ex06/src/clojure_ref_sequences.clj#r=g11366>
				(first [1 2 3]) ;; => 1
				(ffirst [[3 4] [1 2]]) ;; => 3
				(nfirst [[3 4] [1 2]]) ;; => (4)
				(second [1 2 3]) ;; => 2
				(nth [:a :b :c] 2) ;; => :c
				(when-first [a [1 2]] a) ;; => 1
				(last [1 2 3]) ;; => 3
				(rand-nth [1 2 3]) ;; => 2
			;; sect09: seq -> collection <url:ex/study_clojure/ex06/src/clojure_ref_sequences.clj#r=g11367>
				(zipmap [:a :b] [1 2]) ;; => {:a 1, :b 2}
				(into (sorted-map) {:b 1 :a 2}) ;; => {:a 2, :b 1}
				(reduce + [1 2 3]) ;; => 6
				(set [1 2 1]) ;; => #{1 2}
				(vec '(1 2 3)) ;; => [1 2 3]
				(frequencies [:a :b :a]) ;; => {:a 2, :b 1}
				(group-by count ["ali" "ab" "axe"]) ;; => {3 ["ali" "axe"], 2 ["ab"]}
			;; sect10: pass items to a function <url:ex/study_clojure/ex06/src/clojure_ref_sequences.clj#r=g11368>
				(apply str [1 2 3]) ;; => "123"
				(str [1 2 3]) ;; => "[1 2 3]"
				(str 123) ;; => "123"
			;; sect11: compute boolean <url:ex/study_clojure/ex06/src/clojure_ref_sequences.clj#r=g11369>
				(not-empty [1 2]) ;; => [1 2]
				(not-empty "hello") ;; => "hello"
				(some even? [1 2 3]) ;; => true
				(seq? [1 2 3]) ;; => false
				(every? even? [1 2]) ;; => false
				(not-every? even? [1 2]) ;; => true
				(not-any? even? [1 2]) ;; => false
				(empty? [1 2]) ;; => false
	core id=g11867
		assoc assoc-in update update-in
			ref: ~/projects/study/clj/ex/study_clojure/ex06/src/assoc_update.clj
			update-in
				; update-in <url:clojure.md#r=g11287>
				(def p {:name "James" :age 26})
				(update-in p [:age] inc) ;;=> {:name "James", :age 27}
			assoc-in
				; assoc-in <url:clojure.md#r=g11288>
				ref: ~/projects/study/clj/ex/study_clojure/ex06/src/assoc_update.clj
				(assoc-in {:person {:name "Mike"}} [:person :name] "Violet") ; => {:person {:name "Violet"}}
				(assoc-in {:person {:name "Mike"}} [:person] "Violet") ; => {:person "Violet"}
		reduce-kv
			; reduce-kv <url:file:///~/projects/study/clj/ex/study_clojure/ex06/src/core01.clj#r=g11445>
			(reduce-kv #(assoc %1 %3 %2) {} {:a 1 :b 2}) ;; => {1 :a, 2 :b}
			(reduce-kv (fn [m k v] (assoc m k (inc v))) 
				{} {:a 1 :b 2}) ;; => {:a 2, :b 3}
		keep
			; keep  <url:file:///~/projects/study/clj/ex/study_clojure/ex06/src/core01.clj#r=g11436>
			(keep #(if (odd? %) %) (range 4)) ;;=> (1 3 5 7 9)
		literals
			Strings (character types) <url:book_learn_clojure.md#r=g11315>
			Symbols and idents: <url:book_learn_clojure.md#r=g11316>
			"hello"         ; string
			\e              ; character
			#"[0-9]+"       ; regular expression
			'(1 2 3)     ; list
			[1 2 3]      ; vector
			#{1 2 3}     ; set
			{:a 1, :b 2} ; map
		complement
			; complement <url:file:///~/projects/study/clj/ex/study_clojure/ex06/src/core01.clj#r=g11434>
			(def not-empty? (complement empty?))
			(not-empty? [1 2]) ;;=> true
		map
			; map doc <url:clojure.md#r=g11276>
			(map f coll)
			(map + [1 2 3] [4 5 6]) ;;=> (5 7 9)
			; map <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11338>
			(map vector [:a :b] [:d :e]) ;; => ([:a :d] [:b :e])
			(map inc [1 2]) ;; => (2 3)
			(map key {:a 1 :b 2}) ;; => (:a :b)
		reduce id=g11310
			ref: ~/projects/study/clj/ex/study_clojure/ex06/src/reduce.clj
			; reduce <url:clojure.md#r=g11306>
			; reduce <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11337>
			(reduce + [1 2 3]) ;; => 6
			(reduce (fn [rst x] (+ rst x)) [1 2 3]) ;; => 6
			(reduce + -10 [1 2 3]) ;; => -4
		into
			; into <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11339>
			(into [1 2] '(3 4)) ;; => [1 2 3 4]
			(into [] '(1 2)) ;; => [1 2]
			(into {} [[:a 1] [:b 2]]) ;; => {:a 1, :b 2}
			(into [] {:a 1 :b 2}) ;; => [[:a 1] [:b 2]]
		mapv
			; mapv function <url:clojure.md#r=g11292>
			(mapv + [1 2] [3 4]) ;; => [4 6]
		hash-map
			; hash-map function <url:clojure.md#r=g11293>
				(hash-map :key1 'val1) ;; => {:key1 val1}
				(hash-map [:compound :key] nil) ; compound key ;; => {[:compound :key] nil} 
			; Hashmaps <url:clojure.md#r=g11298>
				constructor function
					(hash-map :a 1 :b 2) ;; => {:b 2, :a 1}
				hashmap literal
					{:a 1 :b 2} ;; => {:a 1, :b 2}
			; Converting collections to hashmaps <url:clojure.md#r=g11299>
				(hash-map [:a 1 :b 2 :c 3]) ;; => IllegalArgumentException 
				(apply hash-map [:a 1 :b 2 :c 3]) ;; => {:c 3, :b 2, :a 1}
		map-indexed
			; map-indexed function <url:clojure.md#r=g11295>
			(map-indexed hash-map "foobar") ;; => ({0 "f"} {1 "o"} {2 "o"} {3 "b"} {4 "a"} {5 "r"})
		iterations
			; iterations <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11340>
			(take 3 (iterate inc 3)) ;; => (3 4 5)
			(range 1 3) ;; => (1 2)
			(repeatedly 3 #(str "hi")) ;; => ("hi" "hi" "hi")
			(doseq [a [1 2 3]] (println a)) ;; => nil
			(dotimes [i 3] (println i)) ;; 0 ;; 1 ;; 2 ;; => nil
		take
			; take drop <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11342>
			(take 5 (range 0 100)) ;; => (0 1 2 3 4)
			(take-while pos? [1 2 -3 4]) ;; => (1 2)
			(drop 3 (range 0 10)) ;; => (3 4 5 6 7 8 9)
			(drop-while pos? [1 2 -3 4]) ;; => (-3 4)
		filter
			; filter <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11343>
			(filter pos? [1 2 -3 4]) ;; => (1 2 4)
			(remove pos? [1 2 -3 4]) ;; => (-3)
		group-by partition-by
			; grouping <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11344>
			(partition-by pos? [1 2 -3]) ;; => ((1 2) (-3))
			(group-by pos? [1 2 -3]) ;; => {true [1 2], false [-3]}
		for: list comprehension
			; list comprehension <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11345>
			(for [x [1 2 3]] (+ 5 x)) ;; => (6 7 8)
			(for [x [-1 2 3] :when (< 0 x)] x) ;; => (2 3)
			(for [x [1 2 3] :let [y (+ x 1)] when (even? y)] y) ;; => (2 4)
			(for [x (range 3) :while (< x 2)] x) ;; => (0 1)
		vec
			; vec function <url:clojure.md#r=g11296>
			(vec '(1 2 3)) ;; => [1 2 3]
		partial
			; partial doc <url:clojure.md#r=g11277>
			(partial f arg1)
			(def hundred-times (partial * 100))
		apply
			; apply doc <url:clojure.md#r=g11278>
			(apply f args)
			(apply max [1 2 3])
			(apply + [1 2 3]) ;; => 6
			(apply hash-map [:a 1 :b 2 :c 3]) ;; => {:c 3, :b 2, :a 1}
		comp
			; comp doc <url:clojure.md#r=g11279>
			(comp f g)
			((comp str +) 8 8 8)   
		juxt
			; juxt doc <url:clojure.md#r=g11280>
			((juxt a b c) x) => [(a x) (b x) (c x)]
			((juxt :a :b) {:a 1 :b 2 :c 3 :d 4}) ;;=> [1 2]
			((juxt identity name) :keyword) ;;=> [:keyword "keyword"]
		identity
			; identity doc <url:clojure.md#r=g11281>
			(identity 4) ;; => 4
		name
			; name doc <url:clojure.md#r=g11282>
			(name :x) ;;=> "x"
		pr-str
			; pr-str doc <url:clojure.md#r=g11283>
			(pr-str x) ;; => "[1 2 3 4 5]"
			(read-string (pr-str x)) ;; => [1 2 3 4 5]
		repeat
			; repeat doc <url:clojure.md#r=g11284>
			(take 5 (repeat "x")) ;; => ("x" "x" "x" "x" "x")
			(repeat 5 "x")
		into
			; into doc <url:clojure.md#r=g11285>
			(into () '(1 2 3)) ;; => (3 2 1)
			(into [1 2 3] '(4 5 6)) ;; => [1 2 3 4 5 6]
			(into (sorted-map) [ [:a 1] [:c 3] [:b 2] ] ) ;; => {:a 1, :b 2, :c 3}
			(into [] {1 2, 3 4}) ;; => [[1 2] [3 4]]
		remove
			; remove doc <url:clojure.md#r=g11286>
			(remove even? (range 10)) ;;=> (1 3 5 7 9)
			(remove #(> (second %) 100) {:a 1 c 101 }) ;;=> ([:a 1] )
			(map #(> (second %) 100) {:a 1 :c 101}) ;; => (false true)
		swap!
			; swap! amap assoc akey nasıl çalışıyor? <url:clojure.md#r=g11289>
			(def m (atom {:a 1}))
			(swap! m assoc :b 2) ;; => {:a 1, :b 2}
		defonce
			; defonce <url:clojure.md#r=g11290>
			(defonce foo 5)
			(defonce foo 10) ;; => nil
		namespaced keyword (qualified keywords) (namespaced maps)
			; namespaced keyword notations <url:clojure.md#r=g11294>
			#:a{:b :c} ;; => #:a{:b :c}
			{:a/b :c} ;; => #:a{:b :c}
			ref: Destructuring qualified keywords <url:file:///~/projects/study/clj/clojure.md#r=g12377>
			ref: Destructuring qualified keywords of alias namespaces  <url:file:///~/projects/study/clj/clojure.md#r=g12378>
		io file read write
			; slurp: read file url <url:file:///~/projects/study/clj/ex/study_clojure/ex06/src/core01.clj#r=g11404>
			(spit "tmp.txt" "test")
			(slurp "tmp.txt") ;; => "test"
	libraries
		specter id=g11443
			; ex: Increment every even number nested within map of vector of maps <url:file:///~/projects/study/clj/ex/study_specter/e01/src/specter01.clj#r=g11441>
				(def data {:a [{:aa 1 :bb 2} {:cc 3}] b [{:dd 4}]})
				(transform [MAP-VALS ALL MAP-VALS even?] inc data) ;; => {:a [{:aa 1, :bb 3} {:cc 3}], :b [{:dd 5}]}
			; ex: Append a sequence of elements to a nested vector <url:file:///~/projects/study/clj/ex/study_specter/e01/src/specter01.clj#r=g11440>
				(def data {:a [1 2 3]})
				(setval [:a END] [4 5] data) ;; => {:a [1 2 3 4 5]}
			; ex: Increment the last odd number in a sequence <url:file:///~/projects/study/clj/ex/study_specter/e01/src/specter01.clj#r=g11442>
				(def data [1 2 3 4])
				(transform [(filterer odd?) LAST] inc data) ;; => [1 2 4 4]
		string id=g13009
			; capitalization of a string <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11372>
				(str/capitalize "a b. c d.") ;; => "A b. c d."
				(str/upper-case "ab c") ;; => "AB C"
				(str/lower-case "A B") ;; => "a b"
			; Clean Whitespace in a String  <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11373>
				(str/trim " \ta b\n") ;; => "a b"
				(str/replace "a\t\nb c\fd" #"\s+" " ") ;; => "a b c d"
			; Combine/Join a String <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11374>
				(str "a" " " "b") ;; => "a b"
				(def lines ["#! /bin/bash\n", "du -a ./ | sort -n -r\n"]) 
				(apply str lines) ;; -> "#! /bin/bash\ndu -a ./ | sort -n -r\n"
				(def f ["a" "b"]) (str/join ", " f)
				(str/join [1 2 3 4]) ;; => "1234"
				;; Constructing a CSV from a header string and vector of rows
					(def header "a,b\n")
					(def rows ["10,20","11,21"])
					(apply str header (interpose "\n" rows))
					;; => "a,b\n10,20\n11,21"
			; String to Character <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11375>
				(seq "ali") ;; => (\a \l \i)
				(frequencies (str/lower-case "aa b")) ;; => {\a 2, \space 1, \b 1}
				; all_upper?
					(defn all_upper? [s] (every? #(or (not (Character/isLetter %)) (Character/isUpperCase %)) s))
					(all_upper? "A B") ;; => true
					(all_upper? "A b") ;; => false
			; Character to/from Integer <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11376>
				(int \a) ;; -> 97
				(map int "a b") ;; => (97 32 98)
				(char 97) ;; -> \a
			; Formatting Strings <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11377>
				(def me {:k "v"})
				(str "key: " (:k me)) ;; => "key: v"
				(apply str (interpose " " [1 2.000 (/ 3 1) (/ 4 9)])) ;; -> "1 2.0 3 4/9"
				;; format
					(defn filename [name i] (format "%03d-%s" i name))
					(filename "file.txt" 12)
					;; => "012-file.txt"
			; Pluralizing Strings <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11380>
				(require '[inflections.core :as inf])
				(inf/pluralize 1 "monkey") ;; -> "1 monkey"
				(inf/pluralize 12 "monkey") ;; -> "12 monkeys"
			; Converting Between Strings, Symbols, and Keywords <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11381>
				(symbol "a?") ;; => a?
				(str 'a?) ;; => "a?"
				(name :a) ;; => "a"
				(str :a) ;; => ":a"
				(keyword "a") ;; => :a
				(keyword 'a) ;; => :a
				(symbol (name :a)) ;; => a
				(name :user/a?) ;; => "a?"
				(namespace :user/a?) ;; => "user"
		regex
			; Regex Match <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11378>
				(re-find #"\d+" "ab 12") ;; => "12"
				(re-matches #"\w+" "ab c") ;; => nil
				(re-seq #"\w+" "ab c") ;; => ("ab" "c")
				(defn mentions [tweet] (re-seq #"(@|#)(\w+)" tweet))
				(mentions "ab @c de. #fg")
				;; => (["@c" "@" "c"] ["#fg" "#" "fg"])
			; Regex Replace <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11379>
				(str/replace "a b" "a" "c") ;; => "c b"
				(str/split "A,B" #",") ;; => ["A" "B"]
		clj-time
			(require '[clj-time.core :as t])
			(str (t/now)) ;; => "2019-11-01T11:53:40.214Z"
		number
			; BigDecimal BigInt
				(+ 1 0.0001M) ;; 1.0001M
				(+ 1 1000000000000000N)
			; Precision Numbers <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11382>
				2.1e2 ;; -> 2.1E2
				1e-10 ;; -> 1.0E-10
				(* 9999 9999 9999 9999 9999) ;; ArithmeticException integer overflow  clojure.lang.Numbers.throwIntOverflow
				(*' 9999 9999 9999 9999 9999) ;; => 99950009999000049999N
			; Rational Numbers <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11383>
				(/ 1 3) ;; -> 1/3
				(type (/ 1 3)) ;; -> clojure.lang.Ratio
				(* 3 (/ 1 3)) ;; -> 1N
				(rationalize 0.3) ;; -> 3/10
				(+ (/ 1 3) (rationalize 0.3)) ;; -> 19/30
			; Parsing Numbers <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11384>
				(Integer/parseInt "-42") ;; -> -42
				(Double/parseDouble "3.14") ;; -> 3.14
			; Rounding and Truncating <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11385>
				(int 2.0001) ;; -> 2
				(int 2.999999999) ;; -> 2
				(Math/round 2.0001) ;; -> 2
				(Math/round 2.999) ;; -> 3
			; Fuzzy Comparison <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11386>
				(defn fuzzy= [tolerance x y]
					(let [diff (Math/abs (- x y))]
						(< diff tolerance)))
				(fuzzy= 0.01 10 10.001)
				;; => true
			; Trigonometry <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11388>
				(Math/sin 0.1) ;; => 0.09983341664682815
			; Different Bases <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11387>
				(int 2r101) ;; => 5
				(int 16r2A) ;; => 42
				(Integer/toString 5 2) ;; => "101"
			; Random Numbers <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11389>
				(rand) ;; -> 0.0249306187447903
				(inc (rand-int 6)) ;; => 1
				(rand-nth '(:a :b :c)) ;; -> :c
				(rand-nth (seq #{:heads :tails})) ;; -> :heads
				(shuffle [1 2 3 4 5 6]) ;; -> [3 1 4 5 2 6]
			; imprecise numbers <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11391>
				(- 0.23 0.24) ;; -> -0.009999999999999981
		uuid
			; uuid global identifiers <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11390>
				(java.util.UUID/randomUUID) ;; -> #uuid "5358e6e3-7f81-40f0-84e5-750e29e6ee05"
				(def u1 (squuid))
				u1 ;; -> #uuid "527bf210-dfae-4c73-8b7a-302d3b511f41"
		date time
			; Date and Time <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11392>
				(defn now [] (java.util.Date.))
				(now) ;; => #inst "2020-06-16T18:44:08.981-00:00"
				; unix timestamp
				(System/currentTimeMillis) ;; => 1592333064027
			; Dates as Literals <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11393>
				(def my-birthday #inst "1987-02-18T18:00:00.000-00:00")
				(println my-birthday) ;; #inst "1987-02-18T18:00:00.000-00:00"
			; Parsing Dates <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11394>
				(require '[clj-time.format :as tf])
				(tf/parse (tf/formatter "MM/dd/yy") "02/18/87") ;; -> #<DateTime 1987-02-18T00:00:00.000Z>
			; Formatting Dates <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11395>
			; Convert joda from/to java date instances <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11396>
			; Comparing Dates <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11397>
				(defn now [] (java.util.Date.))
				(def one-second-ago (now))
				(compare (now) one-second-ago) ;; -> 1
				(def occurrences [#inst "2013-04-06T17:40:57.688-00:00" #inst "2002-12-25T00:40:57.688-00:00"])
				(sort occurrences) ;; => (#inst "2002-12-25T00:40:57.688-00:00" #inst "2013-04-06T17:40:57.688-00:00")
			; Time Interval Between <url:ex/study_clojure/ex06/src/book_clojure_cookbook_van_der_hart.clj#r=g11398>
		edn edn2
			ref: 
				[Learn edn in Y Minutes](https://learnxinyminutes.com/docs/edn/)
			edn-format/edn: Extensible Data Notation <url:book_clojure_documentation.md#r=g11402>
			Tagging elements: #tag {:a 1}
	datomic id=g12850
		rfr
			articles - datomic <url:file:///~/projects/study/clj/clojure.otl#r=g13040>
			gtd - datomic <url:file:///~/projects/study/clj/clojure.otl#r=g13063>
		datomic.otl <url:file:///~/projects/study/clj/datomic.otl>
		datalog-01 /Users/mertnuhoglu/projects/study/clj/ex/study_datomic/datalog-01/deps.edn
	concepts
		record defrecord
			ref: defrecord <url:file:///~/projects/study/clj/art_clojure_language_brian_will.md#r=g12114>
				ex
					(defrecord Nadine [x y z] ; fields
						Roger ; protocol implemented
						(foo [this]
					(def adam (new Nadine 3 "hi" false)) ; new special form
					(foo adam 7 2) ; instance adam: adam.foo(7, 2)
					(. adam x) ; adam.x field access
					(get adam :x) ; adam.x as keyword
				defprotocol = interface
				defrecord = class
				map fct returns a new record
					(assoc adam :x 5) ; new Nadine record {:x 5 :y "hi" :z false}
			ref: create types <url:file:///~/projects/study/clj/art_clojure_language_brian_will.md#r=g12115>
				deftype: for data structure
				defrecord: for domain data
			ref: record <url:ex/study_clojure/ex06/src/core01.clj#r=g11410>
				(defrecord Book [title author])
				(->Book "title01" "author01") ;; => #user.Book{:title "title01", :author "author01"}
		global bindings
			; bindings: defn vs def <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11323>
				(defn f [a] a)
				(def g (fn [a] a))
				(defn documented "This is documentation" [] (str ""))
		quoting
			(quote (1 2 3)) ;; (1 2 3)
			(type 'quoted-symbols-are-not-evaluated) ;; => clojure.lang.Symbol
			; quotes <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11349>
				(quote (+ 1 2)) ;; => (+ 1 2)
				'(+ 1 2) ;; => (+ 1 2)
			; syntax-quoting  <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11350>
				`(+ 1 2) ;; => (clojure.core/+ 1 2)
				`(+ 1 ~(inc 1)) ;; => (clojure.core/+ 1 2)
				`(+ ~(list 1 2)) ;; => (clojure.core/+ (1 2))
				`(+ ~@(list 1 2)) ;; => (clojure.core/+ 1 2)
			; Delaying evaluation with quoting <url:book_learn_clojure.md#r=g11317>
				'x
				'(1 2 3)
		special forms
			; Special Forms <url:clojure.md#r=g11300>
				unlike function calls, they don’t always evaluate all of their operands
				you can’t use them as arguments to functions
				; var and reader macro  <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11325>
					(meta (var documented))
					(meta #'documented)
					;; => {:arglists ([]), :doc "This is documentation", :line 65, :column 1, :file "/Users/mertnuhoglu/projects/study/clj/ex/study_clojure/ex06/src/ex_kimh.clj", :name documented, :ns #namespace[clojure_by_example_kimh]}
		multi-arity
			; Multi-arity <url:clojure.md#r=g11301>
				(defn plus
					([a b] (+ a b))
					([a] (+ a)))
				default values for arguments
					(defn fn1
						([a b] (str a b))
						([a] (fn1 a "karate")))
		variable-arity
			; Variable-arity <url:clojure.md#r=g11302>
				(defn fn1
					[name & things]
					(str name (clojure.string/join ", " things)))
		variadic
			; variadic function <url:ex/study_clojure/ex06/src/core01.clj#r=g11358>
			(defn f [x & xs] (str x xs))
			(f 1 2 3) ;; => "1(2 3)"
		destructuring id=g11904
			; Destructuring <url:clojure.md#r=g11303>
				(defn fn1 [[a]] a)
				(fn1 [1 2 3]) ;; => 1
			; destructuring <url:file:///~/projects/study/clj/ex/study_clojure/ex06/src/destructuring.clj#r=g11408>
				(let [[a b & c :as d] [1 2 3 4]] [a b]) ;; => [1 2]
				(let [[a b & c :as d] [1 2 3 4]] [c]) ;; => [(3 4)]
				(let [[a b & c :as d] [1 2 3 4]] [d]) ;; => [[1 2 3 4]]
				(let [{a :a, c :c}  {:a 5 :c 6}] [a c]) ;; [5 6]
				(let [{a :a, :as m} {:a 2 :b 3}] [a m]) ;; => [2 {:a 2, :b 3}]
			; Destructuring qualified keywords <url:file:///~/projects/study/clj/clojure.md#r=g12377>
				(def props {:car/make "Škoda", :ui/selected? false})
				;; 1. :<ns>/keys [..]
				(let [{:car/keys [make], :ui/keys [selected?]} props] [make selected?])
				;; 2. :keys [<ns1>/key1, <ns2>/key2, ...]
				(let [{:keys [car/make ui/selected?]} props] [make selected?])
				;; 3. <symbol> <qualified keyword>
				(let [{make :car/make, selected? :ui/selected?]} props] [make selected?])
			; Destructuring qualified keywords of alias namespaces  <url:file:///~/projects/study/clj/clojure.md#r=g12378>
				; Alias ile qualify edilen keyword iki tane `:` gerektirir: `::<ns_alias>/kwd`
				; Eğer alias ile qualify etmeden çift `:` kullanırsan, current ns ile genişletilir: `::kwd` = `:<current_ns>/kwd`
				(ns myns (:require [my.domain.car :as car]))
				(def props {::car/make "Škoda", :my.domain.car/year 2020, ::sold? true})
				(let [{::car/keys [make year], ::keys [sold?], sold2? :myns/sold?} props]
					(println make year sold? sold2?))
				; OUT> Škoda 2020 true true
		anonymous functions
			; anonymous functions <url:clojure.md#r=g11304>
				(#(identity %&) 1 "blarg" :yip) ;; => (1 "blarg" :yip)
			; anonymous functions <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11322>
				((fn [x] (+ 6 x)) 3) ;; => 9
				(#(+ 6 %) 3) ;; => 9
				(#(+ 6 %1) 3) ;; => 9
		higher-order-functions
			; higher-order-functions <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11326>
				(defn h [fun] (fun 10))
				(h inc) ;; => 11
		closures
			; returning functions <url:clojure.md#r=g11305>
				(defn inc-maker [inc-by] #(+ % inc-by))
				(def inc3 (inc-maker 3))
				(inc3 7) ;; => 10
			; closure  <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11327>
				(defn closure [a] #(inc a))
				(def outer (closure 20))
				(outer) ;; => 21
		namespaces
			Namespaces <url:book_programming_in_clojure.md#r=g11412>
				`in-ns`: create/switch namespace
					(in-ns 'myapp)
				You should `use` `clojure.core` namespace when you move to a new namespace.
					(clojure.core/use 'clojure.core)
				a symbol will resolve to in the current namespace:
					(resolve 'foo) ;; #'test01.core/foo
				Class names outside `java.lang` must be fully qualified:
					java.io.File/separator ;; "/"
					(import '(java.io InputStream File)) ;; java.io.File
				ns macro: (ns name & references)
					(ns examples.exploring
						(:require [clojure.string :as str])
						(:import (java.io File)))
			; Namespaces <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11328>
				(in-ns 'user)
				(require 'clojure_by_example_kimh)
				(clojure_by_example_kimh/outer) ;; => 21
				(require '[clojure_by_example_kimh :as cbe])
				(cbe/outer) ;; => 21
			Namespace <url:book_clojure_practicalli.md#r=g11405>
				opt01: use a function
					(ns my-namespace.core :require [clojure.java.io])
					(clojure.java.io/reader filename)
				opt02: use alias
					(ns my-namespace.core :require [clojure.java.io :as java-io])
					(java-io/reader filename)
				opt03: no qualifier
					(ns my-namespace.core :require [clojure.java.io :refer [reader]])
					(reader filename)
				opt04: multiple namespaces
					(ns duct-test.main
						(:require [clojure.java.io :as io]
											[com.stuartsierra.component :as component]
											[duct.middleware.errors :refer [wrap-hide-errors]]
						))
				extarnal libraries in project file: 
					:dependencies [[org.clojure/clojure "1.7.0"]
												 [org.clojure/clojurescript "1.7.122"]
												 [com.stuartsierra/component "0.3.0"]
		control flow
			; control clow <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11329>
				(if (< 3 5) "then" "else") ;; => "then"
				(if-let [a 1] a 0) ;; => 1
				(when true "10") ;; => "10"
				(let [n 2] (case n 1 "a" 2 "b" "other")) ;; => "b"
		let
			; let <url:clojure.md#r=g11307>
				(let [[a & b] [1 2 3]] [a b]) ;; => [1 (2 3)]
		loop id=g11309
			; loop <url:clojure.md#r=g11308>
				(loop [i 0]
					(println (str i))
					(if (> i 1)
						(println "Goodbye!")
						(recur (inc i))))
				; => 0
				; => 1
				; => Goodbye!
		java calls
			; invoking java code <url:book_learn_clojure.md#r=g11324>
				| Instantiation   | new Widget("foo") | (Widget. "foo")  |
				| Instance method | rnd.nextInt()     | (.nextInt rnd)   |
				| Instance field  | object.field      | (.-field object) |
				| Static method   | Math.sqrt(25)     | (Math/sqrt 25)   |
				| Static field    | Math.PI           | Math/PI          |
			; java <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11357>
				(new java.util.Date) ;; => #inst "2020-06-15T14:27:36.415-00:00"
				(java.util.Date. "2016/2/19") ;; => #inst "2016-02-18T22:00:00.000-00:00"
				(let [d (java.util.Date.)] (str d)) ;; => "Mon Jun 15 17:27:43 EEST 2020"
				(Math/pow 2 3) ;; => 8.0
				(let [d (java.util.Date.)] (.toString d)) ;; => "Mon Jun 15 17:27:47 EEST 2020"
				(let [d (java.util.Date.)] (. d toString)) ;; => "Mon Jun 15 17:27:51 EEST 2020"
			dot dot syntax <url:book_programming_in_clojure.md#r=g11413>
				(.. System (getProperties) (get "os.name"))
				;; expands to:
				(. (. System (getProperties)) (get "os.name"))
				(-> (System/getProperties) (.get "os.name"))
		recursions
			; recursion <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11346>
			(defn length2 [result xs]
				(if (empty? xs)
					result
					(recur (+ 1 result) (rest xs))))
			(length2 0 [3 4]) ;; => 2
		loop
			; loop <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11347>
			(loop [i 0]
				(if (= i 3)
					(println "done!")
					(do
						(println i)
						(recur (inc i)))))
		macros macro2
			~/projects/study/clj/ex/study_clojure/ex06/src/macro.clj
				(macroexpand '(-> c (+ 3) (* 2)))
			; macros <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11348>
			ex: unless
				(defmacro unless [cond then]
					(list
						'if
						(list 'not cond)
						then))
				(unless false 1) ;; => 1
			(macroexpand '(unless false 1)) ;; => (if (not false) 1)
		threading
			; threading macros <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11351>
				(-> [] (conj 1) (conj 2)) ;; => [1 2]
				(->> [1 2] (map inc) (map #(* 2 %))) ;; => (4 6)
		delay
			; delay <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11352>
			(def later (do [] (prn "Adding") (+ 1 2)))
			(def later (delay [] (prn "Adding") (+ 1 2)))
		atom
			; atom <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11353>
			(def a (atom 1)) ;; => #'user/a
			(deref a) ;; => 1
			(reset! a 2) ;; => 2
			(swap! a #(inc %)) ;; => 3
			(defn multiple-by [an-atom n] (* an-atom n))
			(swap! a multiple-by 3) ;; => 9
		thread safety
			; thread safety <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11354>
		ref
			; ref <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11355>
		transaction ref-set
			; transaction ref-set <url:ex/study_clojure/ex06/src/ex_kimh.clj#r=g11356>
		Weird Characters <url:book_clojure_documentation.md#r=g11401>
			# - Dispatch character
			#{ … } - Set
			#_ - Discard
			#"…" - Regular Expression
			#(…) - Anonymous function
			#' - Var quote
			## - Symbolic values
			#inst, #uuid, and #js etc. - tagged literals
			%, %n, %& - Anonymous function arguments
			@ - Deref
			^ (and #^) - Metadata
			' - Quote
			; - Comment
			: - Keyword
			:: - Auto-resolved keyword
			#: and #:: - Namespace Map Syntax
			/ - Namespace separator
			\ - Character literal
			$ - Inner class reference
			->, ->>, some->, cond->, as-> etc. - Threading macros
			` - Syntax quote
			~ - Unquote
			~@ - Unquote splicing
			<symbol># - Gensym
			#? - Reader conditional
			#?@ - Splicing Reader conditional
			*var-name* - "Earmuffs"
			>!!, <!!, >!, and <! - core.async channel macros
			<symbol>? - Predicate Suffix
			<symbol>! - Unsafe Operations
			_ - Unused argument
			, - Whitespace character
			#= Reader eval
			& rest parameters
	conventions
		side-effect functions
			side-effect funs return nil as result
	cli
		install
			brew install clojure
		run
			; Writing a program <url:clojure.md#r=g11297>
			clj -m hello ;; => Hello world, the time is 02:57 PM
		new project <url:book_clojure_documentation.md#r=g11399>
			lein new app proj01
			cd proj01
			lein run
	articles
		; Article: Functional-navigational programming in Clojure(Script) with Specter <url:clojure.md#r=g11311>
	repl
		start repl
			lein repl
			Interactive Development <url:book_clojure_documentation.md#r=g11400>
				lein repl
				(-main) ;; Hello, World!
				(require 'proj01.core :reload)
				(-main) ;; Hello, World!2
		doc
			(doc map)
		; repl <url:examples_clojure.md#r=g11312>
		; REPL <url:book_learn_clojure.md#r=g11318>
		history
			(+ 3 4) ;; => 7
			(+ 10 *1) ;; => 17
			(+ 1 2) (+ 1 3) (str *1 *2) ;; => "11106"
		apropos: find functions
			(apropos "+") ;; => (clojure.core/+ clojure.core/+')
		dir: list functions in namespace
			(dir clojure.repl)
		print
			; Printing <url:book_learn_clojure.md#r=g11319>
			(println "What is this:" (+ 1 2))
			; printing https://clojuredocs.org/clojure.core/pr <url:ex/study_clojure/ex06/src/core01.clj#r=g11321>
				(pr ['a :b "\n" \space "c"]) ;; [a :b "\n" \space "c"]nil
				(print ['a :b "\n" \space "c"])
				;; [a :b
				;;  c]nil
		special variables
			Whats my environment <url:book_clojure_practicalli.md#r=g11403>
			*clojure-version* ;; {:major 1, :minor 9, :incremental 0, :qualifier nil}
			*compile-path* ;; "/Users/mertnuhoglu/codes/clojure/clojure-through-code/target/classes"
			*ns* ;; #object[clojure.lang.Namespace 0x209a5cf "user"]
		special functions
			Special Variables <url:book_programming_in_clojure.md#r=g11409>
			(pst) ; print stack trace
			(load-file "file.clj")
			(find-doc "reduce") 
			(source identity)
	tools
		ides
			doom
				Bir projeyi REPL ile incelemek <url:file:///~/projects/study/emacs/doom.md#r=g12073>
			spacemacs
				; spacemacs refcard <url:~/projects/study/emacs/spacemacs.md#r=g11015>
					| SPC SPC   | list and search all commands | M-x                         |
					| SPC m     | cider menu                   | ,                           |
					| '         | start REPL                   | cider-jack-in               |
					| e c       | eval expression as comment   | cider-eval-defun-to-comment |
			cursive intellij
				Bir projeyi REPL ile incelemek  <url:file:///~/projects/study/clj/cursive.md#r=g12072>
				; intellij refcard <url:~/projects/study/code/study_intellij.md#r=g11014>
				; compatible keybindings: spacemacs and intellij <url:~/.ideavimrc#r=g10991>
					| ^^ repl | run repl           |
					| SPC sf  | eval sexp          |
					| !+ SPC  | quicklist: popups  |
					| +L C    | quicklist: clojure |
				Remote nREPL Connection id=g12889
					Edit Configurations > Clojure REPL Remote > 
						.Connection Type = nREPL
						Use port from nREPL file > select Project
						Use standard port file
		repl
		json/edn/yaml: ~/projects/study/otl/json.otl
	webapps
		ref
			~/projects/study/clj/book_practicalli_clojure_webapps.md
				~/projects/study/clj/book_practicalli_clojure_webapps_logs.otl
	other
		(instance? java.util.Collection [1 2 3]) ;; true
		Characters: `\{letter} \space \n \r \t`
		(str 1 2 nil 3) ;; "123"
		(find-doc #"\?$") ; Find other predicate functions:
		`#_`: ignore line
			#_(println "hello")
	mine
		ex/study_clojure/ex06/src/ex_kimh.clj
	resources
		exercises katas id=g11414
			http://www.4clojure.com/
				terminal
					https://github.com/porkostomus/ctrain
				problems
					https://github.com/4clojure/4clojure/blob/develop/src/foreclojure/data_set.clj
						/Users/mertnuhoglu/codes/clojure/4clojure/src/foreclojure/data_set.clj
				answers
					https://gist.github.com/SegFaultAX/3607101
						/Users/mertnuhoglu/codes/clojure/gist/3607101/gistfile1.md
			http://clojurescriptkoans.com/
				problems
					https://github.com/lazerwalker/clojurescript-koans
					~/codes/clojure/clojurescript-koans
						~/codes/clojure/clojurescript-koans/README.md
				answers
					https://github.com/mikephys8/clojurescript-koans-solutions
					~/codes/clojure/clojurescript-koans-solutions
						~/codes/clojure/clojurescript-koans-solutions/README.md
			https://github.com/functional-koans/clojure-koans
				problems
					~/codes/clojure/clojure-koans/README.md
				answers
					https://github.com/mkaschenko/clojure-koans
						~/codes/clojure/clojure-koans-answers/README.md
			https://exercism.io/
				~/exercism/clojure/bank-account/test/bank_account_test.clj
			https://www.codewars.com/?language=clojure
			http://www.projecteuler.net/
			https://github.com/clojure-cookbook/clojure-cookbook
				~/codes/clojure/clojure-cookbook/README.md
			http://www.ic.unicamp.br/~meidanis/courses/mc336/2006s2/funcional/L-99_Ninety-Nine_Lisp_Problems.html
			https://github.com/gigasquid/wonderland-clojure-katas
			https://clojurecademy.com/
			https://clojuredocs.org/clojure.core/nth
				https://clojuredocs.org/quickref
				https://clojuredocs.org/core-library
			https://github.com/practicalli/clojure-through-code
				/Users/mertnuhoglu/codes/clojure/clojure-through-code
			http://kimh.github.io/clojure-by-example/#scope
				https://github.com/kimh/clojure-by-example
			https://github.com/nathanmarz/specter-clojure-west/blob/master/src/specter_demo/examples.clj
		other
			https://github.com/shaunlebron/ClojureScript-Syntax-in-15-minutes
			https://en.wikibooks.org/wiki/Clojure_Programming/By_Example
			https://github.com/mythz/clojure-linq-examples
			https://github.com/wtfleming/clojurescript-examples
			https://yogthos.net/ClojureDistilled.html
			https://github.com/life0fun/clojure-idiom
			http://kanaka.github.io/clojurescript/web/synonym.html
			https://clojurescript.org/about/differences
			https://en.wikibooks.org/wiki/Clojure_Programming/Examples/API_Examples
			https://github.com/bbatsov/clojure-style-guide
			https://clojure.org/about/functional_programming
	next
		examples_clojure.md
		reduce loop için daha sade örnekler
			; loop <url:refcard_clojure.otl#r=g11309>
			; reduce <url:refcard_clojure.otl#r=g11310>
flashcards id=g12065
	~/projects/study/clj/book_essential_reference_borgatti.md
		Book: Essential Reference, Borgatti
		-X:project/new :name mertnuhoglu/conjure01
		-X:project/new :name <namespace>/<folder>
		-M:trace:inspect/reveal-nrepl
		rich comment
			(comment ... ,)
	~/projects/study/clj/ex/study_clojure/ex06/src/help_functions.clj
		(clojure.pprint/print-table [{:a 1 :b 2 :c 3}{:a 4 :b 5 :c 6}])
		(all-ns)
		(require '[clojure.repl])
		(ns-publics 'clojure.java.io)
		(clojure.repl/source map)
		(clojure.repl/doc map)
		(clojure.repl/find-doc "create-context")
		(clojure.repl/apropos "unmount-renderer")
		(clojure.repl/apropos "map")
		*ns*
	~/projects/study/clj/ex/study_clojure/ex06/src/require_functions.clj
		(use '[clojure.string :only (split)])
		(require '[clojure.tools.trace :refer [trace, dotrace]])
		(require '[clojure.repl])
		(require '[clojure.pprint :as pp])
	~/projects/study/clj/ex/study_clojure/ex06/src/debug_functions.clj
		(require 'hashp.core)
		(take 3 (repeat #p (+ 1 2)))
		cider debugging: ; put break point: `,db`
		cider debugger: locals:
		#break
	Function Definition
		(macroexpand  ; <1>
			'(defn hello [person]
					(str "hello " person)))
		Metadata Placement
			:doc :tag :pre :post
			(meta #'foo) ; <4>
			(defn ^:bench profile-me [ms]
			~/projects/csl-book-examples/Creatingandmanipulatingfunctions/Functiondefinition/defnanddefn-/6.clj
				(defn- tagged-by [tag nsname]
					(->> (ns-publics nsname)
							 vals
							 (filter #(get (meta %) tag))))
		Documenting
			(clojure.repl/doc hello)
		pre post conditions
			(defn save! [item]
				{:pre [(are [x] x                             ; <1>
								 (map? item)                          ; <2>
								 (integer? (:mult item))              ; <3>
								 (#{:double :triple} (:width item)))] ; <4>
				 :post [(clojure.test/is (= 10 (:id %)))]}    ; <5>
				(assoc item :id (* (:mult item) 2)))
		fn
			Reader macro for function literal: `#()`
			(fn <name>? arities)
			`name` is optional. Used for recursion.
			Multiple arities are used to make `fibo` tail-recursive.
			((fn fibo ; <1>
				([n] (fibo 1 0 n))
				([a b cnt]
				 (if (zero? cnt)
					 b
					 (recur (+ a b) a (dec cnt)))))
			 10)
		Fn and Destructuring
		fnil
			(update {:a 1 :b 2} :c (fnil inc 0)) ; <2>
			(defn say-hello [name] (str "Hello " name))
			(def say-hello-with-defaults (fnil say-hello "World"))
			(defn say-hello [first other] (str "Hello " first " and " other))
			(def say-hello-with-defaults (fnil say-hello "World" "People"))
		comp
			((comp inc +) 2 2) ; <1>
		complement
			({:a 1} :c)
			; nil
			((complement {:a 1}) :c)
			; true
			(filter (complement #{:a}) [:a :b])
		constantly
			((constantly 10) nil)
			; 10
inbox
	20210204 
		debugging cursive: error:
			opt01: jdk1.8 tekrar yükleyip dene
		error: Could not locate clojure/tools/trace__init.class, clojure/tools/trace.clj or clojure/tools/trace.cljc on classpath.
			reproduce:
				cd ~/projects/csl-book-examples
				clojure -M:trace:inspect/reveal-nrepl
				nvim ~/projects/csl-book-examples/Creatingandmanipulatingfunctions/Higherorderfunctions/fnil/6.clj
				burada require çalışmıyor:
					(require '[clojure.tools.trace :refer [trace, dotrace]])
			fix:
				cd ~/projects/study/clj/ex/study_clojure/ex06
				clojure -M:trace:inspect/reveal-nrepl
				nvim ~/projects/study/clj/ex/study_clojure/ex06/src/debug_functions.clj
				bu sefer çalışıyor
			opt04: acaba ns bozuk olduğundan mı çalışmadı ilkinde?
		debug cider
			Showing Intermediary values - Enlighten mode <url:file:///~/projects/study/emacs/book_clojure_with_spacemacs_practicalli.md#r=g11847>
				| , T e | cider-enlighten-mode |
		zprint
			zprint -w file.edn
				pretty prints and writes edn/clj files
	test
		|| name |col|
		| hel | 10 |
	test2
		|no | line|
		| les | klkl| 
	Pets
		+--------+-----+--------+----------------+
		| Name   | Age | Animal | Inside/Outside |
		+========+=====+========+================+
		| Kirby  | 9   | dog    | both           |
		+--------+-----+--------+----------------+
		| Hoover | 1   | dog    | both           |
		+--------+-----+--------+----------------+
		| Sophia | 9   | cat    | inside         |
		+--------+-----+--------+----------------+
	reference functions id=g12855
		standard
			map-indexed
			(map-indexed
			  (fn [idx m]
				  (assoc m :inv/sku (str "SKU-" idx))) ms)
			ffirst
			(mapv #(hash-map :ns/k %) xs)
			(for [color colors size sizes] ...)
			(for [color colors size sizes]
			  {:inv/color color
				 :inv/size size})
		datalog ref id=g12868
			datomic api
				(require '[datomic.client.api :as d])
				d/client
				d/connect client {:db-name "movies"}
				d/transact conn {:tx-data movie-schema}
				d/db conn
				d/q query db
				d/transact conn {:tx-data [{:db/id .. :movie/genre "..."}]}
				d/history db
				{:tx-data [{:db/ident :red} {..}]}
			datomic schema
				{:db/ident ..
				:db/valueType ..
				:db/cardinality ..}
				:db/doc
				:db.type/string
				:db.type/long
				:db.cardinality/one
				:db.cardinality/many
				:db/unique
				:db/unique/identity
				:db/valueType
				:db.type/ref
				:db/id
				:db/id #db/id[:db.part/db]
			datalog query
				'[:find ... :where [e a v]]
				'[:find ?movie-title
					:where [_ :movie/title ?movie-title]]
				'[:find ...
					:where 
					[e a v]
					[e a2 v2]]
				'[find ?title ?genre
					:where [?e .. ?title] 
					[... ?genre]]
				{:order/items 
				[{:item/id [:inv/sku "SKU-25"] 
					:item/count 10}]}
				{:db/ident :item/id
				:db/valueType :db.type/ref}
				{:db/ident :inv/sku
				:db/unique :db.unique/identity}
				'[:find ?..
					:in $ ?inv
					:where [...] [...]]
				db [:inv/sku "SKU-25"]  ; lookup ref
				'[:find ?..
					:in $ % ?inv
					:where (ordered-together ...) [...]]
				db rules [:inv/sku "SKU-25"]  ; lookup ref
			datalog pull
				d/pull db ..
				[:inv/sku "SKU-42"]  ; lookup ref
				d/pull db [{:inv/color [:db/ident]}] [:inv/sku "SKU-42"]
				{:tx-data [nested-data]}
			datalog assert retract
				[:db/add [:inv/sku "..."] :inv/count 10]
				d/transact conn {:tx-data ...}
				[:db/retract [:inv-sku ".."] :inv/count 10]
			datomic history
				'[:find (max 3 ?tx)
					:where [?tx :db/txInstant]]
				d/as-of db txid
			datahike api
				(:require [datahike.api :as dh])
				{:store {:backend :file :path "..."}}
				dh/create-database cfg
				dh/connect cfg
				dh/transact conn [{:db/ident :name ...}]
				dh/transact conn [{:name "alice" ...}]
				dh/transact conn {:tx-data [{...}]}
				dh/q query @conn
				dh/q {:query '{...} 
							:args [@conn]}
				dh/q query (dh/history @conn)
				dh/release conn
				dh/delete-database cfg
				dh/datoms @conn {:index :eavt}
				dh/entity @conn 4
				:friends (dh/entity @conn 4)
				:_friends (dh/entity @conn 4)
				dh/pull @conn [:db/id, :name, {:friends [:db/id :name]}] 4
				dh/schema @conn
		IO
			slurp "file/path"
			read-string (slurp ...)
		logging
			fipp var
		map
			keys m
			vals m
		type checks
			associative?
yayın - clj
	articles - clj
		Rich Hickey articles <url:file:///~/projects/study/clj/clojure.otl#r=g13039>
		articles - datomic <url:file:///~/projects/study/clj/clojure.otl#r=g13040>
		[replikativ / datahike-invoice](https://gitlab.com/replikativ/datahike-invoice) id=g13032
		[learn-clojure/resources](https://roamresearch.com/#/app/Zsolt-Blog/page/AC6_8FVVo) id=g13037
		[(28) Rich Hickey on Datomic Ions, September 12, 2018 - YouTube](https://www.youtube.com/watch?v=thpzXjmYyGk) id=g13038
		[clojure-emacs/clj-refactor.el: A CIDER extension that provides powerful commands for refactoring Clojure code.](https://github.com/clojure-emacs/clj-refactor.el) id=g13056
			[clojure-vim/clj-refactor.nvim: A neovim clojure refactoring plugin](https://github.com/clojure-vim/clj-refactor.nvim)
	örnek uygulamalar - clj id=g13031
		replikativ / datahike-invoice <url:file:///~/projects/study/clj/clojure.otl#r=g13032>
		[Create a form using ClojureScript and Re-Frame - YouTube](https://www.youtube.com/watch?v=46Rs6_2pw_Y) id=g13054
	libraries - clj
		[quoll/asami: A flexible graph store, written in Clojure](https://github.com/quoll/asami) id=g13036
		[daveray/clawk: Like Awk, but Clojure.](https://github.com/daveray/clawk) id=g13041
	Rich Hickey articles id=g13039
		(28) Rich Hickey on Datomic Ions, September 12, 2018 - YouTube <url:file:///~/projects/study/clj/clojure.otl#r=g13038>
	articles - datomic id=g13040
		[homebaseio/datalog-console: Administration UI for Datascript, Datahike, and other Datalog databases](https://github.com/homebaseio/datalog-console)
			[homebaseio/homebase-react: The React state management library for write-heavy applications](https://github.com/homebaseio/homebase-react)
		[(1201) Learn Datalog Today Chapters 1-4 (Clojure Livecoding Stream) - YouTube](https://www.youtube.com/watch?v=8bc4mBRmmbg)
		[Datomic Pull | Datomic](https://docs.datomic.com/on-prem/query/pull.html)
		[Entity Specs — io.replikativ/datahike 0.4.1491](https://cljdoc.org/d/io.replikativ/datahike/0.4.1491/doc/entity-specs)
		[Pull-API Namespace — io.replikativ/datahike 0.4.1491](https://cljdoc.org/d/io.replikativ/datahike/0.4.1491/doc/pull-api-namespace-)
		[Datomic Queries and Rules | Datomic](https://docs.datomic.com/on-prem/query/query.html)
		[(1201) clojureD 2021: "Firetomic: Replacing Datomic with Datahike and Firebase" by Alexander Oloo - YouTube](https://www.youtube.com/watch?v=n0Nb1fY56hU)
		örnek problem çözelim <url:file:///~/projects/myrepo/work/work.otl#r=g12833>
		datahike-invoice örnek kodunu oku <url:file:///~/projects/myrepo/work/work.otl#r=g12831>
		juxt makalesini oluşturmak <url:file:///~/projects/myrepo/work/work.otl#r=g12832>
		datom.com
		[(1201) Intro into using Crux Db with Clojure - YouTube](https://www.youtube.com/watch?v=_L50rsoDBxQ)
		[datahike/cli.md at 336-native-image-cli · replikativ/datahike](https://github.com/replikativ/datahike/blob/336-native-image-cli/doc/cli.md)
		[Turning the database inside-out with Apache Samza — Martin Kleppmann’s blog](https://martin.kleppmann.com/2015/03/04/turning-the-database-inside-out.html)
		[Data structures as queries: Expressing CRDTs using Datalog - Speaker Deck](https://speakerdeck.com/ept/data-structures-as-queries-expressing-crdts-using-datalog?slide=19)
		[(1201) CRDTs: The Hard Parts - YouTube](https://www.youtube.com/watch?v=x7drE24geUw)
		[(1201) CRDTs for Non Academics - YouTube](https://www.youtube.com/watch?v=vBU70EjwGfw)
		[(1201) Datalog all the way down - Christopher Small - YouTube](https://www.youtube.com/watch?v=aI0zVzzoK_E&t=2183s)
		[Clojure in the Database · subhash/clj-stack Wiki](https://github.com/subhash/clj-stack/wiki/Clojure-in-the-Database) id=g13068
		[Datomic MusicBrainz Sample Database – Nextjournal](https://nextjournal.com/kommen/datomic) id=g13066
		[Clojure Datomic Exercise | Kari Marttila Blog](https://www.karimarttila.fi/clojure/2020/11/14/clojure-datomic-exercise.html) id=g13067
		[1: Getting Started with Crux – A Tale of Time and Space – Nextjournal](https://nextjournal.com/crux-tutorial/start)
		[A Bitemporal tale – History. Of histories. – Nextjournal](https://nextjournal.com/crux/a-bitemporal-tale)
		[Conditional Queries in Datomic](https://grishaev.me/en/datomic-query/)
		[Clojure Power Tools Part 1 | Kari Marttila Blog](https://www.karimarttila.fi/clojure/2020/10/26/clojure-power-tools-part-1.html)
		[lilactown/pyramid: A library for storing and querying graph data in a Clojure map](https://github.com/lilactown/pyramid) id=g13061
		[vvvvalvalval/datofu: there's a :db/fn for that](https://github.com/vvvvalvalval/datofu) id=g13062
		[juxt/pull: Trees from tables](https://github.com/juxt/pull) id=g13060
		[subhash/clj-stack: A full-stack Clojure tutorial](https://github.com/subhash/clj-stack)
		[(27) Clojure European Summer Time - Data Driven RAD with Malli, by Arne Brasseur - YouTube](https://www.youtube.com/watch?v=ww9yR_rbgQs)
		[(27) I put 7 years of meal data in Datomic - Here's what I learned - Christian Johansen - YouTube](https://www.youtube.com/watch?v=ORQ2qs8GHsQ)
		[Indexes | Datomic](https://docs.datomic.com/on-prem/query/indexes.html)
		[Entities | Datomic](https://docs.datomic.com/on-prem/overview/entities.html)
		[Transactions | Datomic](https://docs.datomic.com/on-prem/transactions/transactions.html)
		[Tag: Datomic - Curious Programmer](https://curiousprogrammer.dev/tag/datomic)
		[Datomic - codeq](https://blog.datomic.com/2012/10/codeq.html)
		[Home · Datomic/simulant Wiki](https://github.com/Datomic/simulant/wiki)
		[rafd/tada](https://github.com/rafd/tada)
		resources datomic <url:file:///~/projects/study/clj/datomic.otl#r=g12880>
		datomic ile bir json  dosyasında sorgulama yapmayı öğren
		[markbastian/datascript-playground](https://github.com/markbastian/datascript-playground)
		datafy+nav on datomic: [(13) REBL - Stuart Halloway - YouTube](https://www.youtube.com/watch?v=c52QhiXsmyI?t=1272)
			[Clojure Datafy – Nextjournal](https://nextjournal.com/zampino/clojure-datafy)
			[shadow-experiments/dev_support.cljs at master · thheller/shadow-experiments](https://github.com/thheller/shadow-experiments/blob/master/src/main/shadow/experiments/grove/dev_support.cljs)
		REBL Datomic entity'lerini nasıl dolaşıyor?
		[Unofficial guide to Datomic internals @ tonsky.me](https://tonsky.me/blog/unofficial-guide-to-datomic-internals/)
		[Separation of Concerns in Datomic Query: Datalog Query and Pull Expressions](https://cognitect.com/blog/2017/4/21/separation-of-concerns-in-datomic-query-datalog-query-and-pull-expressions)
		[Datomic/mbrainz-importer: Clojure/Transducers/Datomic ETL example](https://github.com/Datomic/mbrainz-importer#readme)
		[Datomic Cheat Sheet Series - Queries (Part 5) - Transactions -...](https://curiousprogrammer.dev/blog/datomic-cheat-sheet-series-queries-part-5-transactions/)
		[(13) Datomic: up and running - YouTube](https://www.youtube.com/watch?v=ao7xEwCjrWQ&t=1769s)
		[(13) David Greenberg - Building Interactive Query Tools on Datomic - YouTube](https://www.youtube.com/watch?v=YHctJMUG8bI)
		[(13) Intro to Datomic - YouTube](https://www.youtube.com/watch?v=RKcqYZZ9RDY)
		[(13) Lucas Cavalcanti & Edward Wible - Exploring four hidden superpowers of Datomic - YouTube](https://www.youtube.com/watch?v=7lm3K8zVOdY)
		[(13) Test-driven Development with Datomic - YouTube](https://www.youtube.com/watch?v=JaZ1Tm6ixCY)
		[Val on Programming: Datomic: Event Sourcing without the hassle](https://vvvvalvalval.github.io/posts/2018-11-12-datomic-event-sourcing-without-the-hassle.html)
		[Val on Programming: Using Datomic in your app: a practical guide](https://vvvvalvalval.github.io/posts/2016-07-24-datomic-web-app-a-practical-guide.html)
		[The Datomic Information Model](https://www.infoq.com/articles/Datomic-Information-Model/)
		[Conversations With Datomic - Squid's Blog](http://gigasquidsoftware.com/blog/2015/08/15/conversations-with-datomic/)
		[Database Reinvented : Datomic | Humble Bits](http://blogs.quovantis.com/introduction-to-datomic/)
		[clojure-cookbook/6-15_traversing-indices.asciidoc at master · clojure-cookbook/clojure-cookbook](https://github.com/clojure-cookbook/clojure-cookbook/blob/master/06_databases/6-15_traversing-indices.asciidoc)
		[clojure-cookbook/6-12_transact-basics.asciidoc at master · clojure-cookbook/clojure-cookbook](https://github.com/clojure-cookbook/clojure-cookbook/blob/master/06_databases/6-12_transact-basics.asciidoc)
		[(13) Datomic Walkthrough Step 0 - Installing, Running Transactor, Console - YouTube](https://www.youtube.com/watch?v=bnBPuN4J_TE)
			[(13) Datomic Walkthrough Step 1 - Connecting and Exploring Datoms - YouTube](https://www.youtube.com/watch?v=bu2bQNiHzgI&list=PL4SAUIEMXDgIZcA2ZXTplhNYqF71_3yfK&index=3)
			[(13) John Madison - YouTube](https://www.youtube.com/channel/UCegjRnOL_zu4nYUkNLsTt1w)
		[tatut/xtdb-inspector: Web UI for inspecting XTDB database](https://github.com/tatut/xtdb-inspector)
		[tatut/ripley: Ring live pages experiment](https://github.com/tatut/ripley)
			photon alternatifi
		[crux-tutorial – Nextjournal](https://nextjournal.com/crux-tutorial)
		[(123) Building a powerful Double Entry Accounting system - Lucas Cavalcanti - YouTube](https://www.youtube.com/watch?v=aw6y4r4NAlw&list=PLZdCLR02grLofiMKo0bCeLHZC0_2rpqsz&index=10)
		[Simulation Testing with Simulant](https://www.infoq.com/presentations/Simulation-Testing/)
		[alexpetrov/datomic-facts-slides: Presentation about Datomic](https://github.com/alexpetrov/datomic-facts-slides)
		[Conversations With Datomic - Squid's Blog](http://gigasquidsoftware.com/blog/2015/08/15/conversations-with-datomic/)
			[Conversations With Datomic Part 2 - Squid's Blog](http://gigasquidsoftware.com/blog/2015/08/19/conversations-with-datomic-part-2/)
			[Conversations With Datomic - Part 3 - Squid's Blog](http://gigasquidsoftware.com/blog/2015/08/25/converstations-with-datomic-3/)
		[Frequent 'datomic' Questions - Stack Overflow](https://stackoverflow.com/questions/tagged/datomic)
		[Datomic Knowledgebase](https://ask.datomic.com/)
		[clojure-north-2020/x07_queries.clj at master · markbastian/clojure-north-2020](https://github.com/markbastian/clojure-north-2020/blob/master/src/clojure_north_2020/ch02_datalog/x07_queries.clj)
		ref türü atributları sırayla takip edebileceğim bir veri yapısı olabilir mi?
		[(28) Learn Reduce, Group-by, and Juxt by creating a Look Up Map (Clojure Tutorial) - YouTube](https://www.youtube.com/watch?v=n0BTsKVs1Lw) id=g13042
		[homebaseio/datalog-console: Administration UI for Datascript, Datahike, and other Datalog databases](https://github.com/homebaseio/datalog-console) id=g13045
		[Rich Hickey's greatest hits |> Changelog](https://changelog.com/posts/rich-hickeys-greatest-hits)
		[Clojure - Evaluation](https://clojure.org/reference/evaluation)
		[Clojure - Functional Programming for the JVM | Object Computing, Inc.](https://objectcomputing.com/resources/publications/sett/march-2009-clojure-functional-programming-for-the-jvm)
		[Visually navigating the data flowing through your serverless functions | Tessellator's Blog](https://www.tessellator.net/blog/visually-navigating-the-data-flowing-through-your-serverless-functions)
		[(35) Defeating the Four Horsemen of the Coding Apocalypse - Mark Bastian - YouTube](https://www.youtube.com/watch?v=jh4hMAvygjk)
		[(35) At the Conjunction of Innovation and Enablement - Mark Bastian - YouTube](https://www.youtube.com/watch?v=7jfH5ZB7deU)
		[(35) Datascript and Datomic: Data Modeling for Heroes - Mark Bastian - YouTube](https://www.youtube.com/watch?v=tV4pHW_WOrY)
		[markbastian/replion: A guide to REPL-driven Datomic development](https://github.com/markbastian/replion)
		[Datomic/datomic-java-examples](https://github.com/Datomic/datomic-java-examples)
		[Datomic/client-examples: Clojure Client API examples](https://github.com/Datomic/client-examples)
		[(35) Building Marvelous and Heroic Systems from the Ground Up - Mark Bastian (Workshop) - YouTube](https://www.youtube.com/watch?v=eink6oICdOQ)
		[markbastian/clojure-north-2020](https://github.com/markbastian/clojure-north-2020)
gtd - clj id=g13055
	ndx - gtd - clj id=g13057
		örnek uygulamalar - clj <url:file:///~/projects/study/clj/clojure.otl#r=g13031>
	sbs - gtd - clj id=g13058
		öncelikli işler
		gtd - datomic id=g13063
			datomic simülasyonları yapalım id=g13064
				bir dosyada olsun adımlar
				step01.clj
				bunun çıktıları başka bir dosyada olsun
				out01.edn
				out01.xlsx
				bunları belki bir Rmarkdown ile birleştirip sunum/rapor haline getirelim
			logseq'te sınıflandırma nasıl yapılıyor? id=g13065
				bir bloka nasıl yeni bir etiket atarım?
	Monad kılavuzunu R ve clj ile uygulamayı dene:
		[(224) The Absolute Best Intro to Monads For Software Engineers - YouTube](https://www.youtube.com/watch?v=C2w45qRc3aU)
	learn-clojure/resources <url:file:///~/projects/study/clj/clojure.otl#r=g13037>
	daveray/clawk: Like Awk, but Clojure. <url:file:///~/projects/study/clj/clojure.otl#r=g13041>
	clojure-emacs/clj-refactor.el: A CIDER extension that provides powerful commands for refactoring Clojure code. <url:file:///~/projects/study/clj/clojure.otl#r=g13056>
	Reduce, Group-by, and Juxt by creating a Look Up Map (Clojure Tutorial) - YouTube <url:file:///~/projects/study/clj/clojure.otl#r=g13042>
	homebaseio/datalog-console: Administration UI for Datascript, Datahike, and other Datalog databases <url:file:///~/projects/study/clj/clojure.otl#r=g13045>
	[(1176) FXL - composable data-oriented spreadsheet library for Clojure - Anthony Khong - Scicloj Meeting 20 - YouTube](https://www.youtube.com/watch?v=d6qOzPQ9NUk)
	[(1181) Wordle clone in ClojureScript - YouTube](https://www.youtube.com/watch?v=QEEPXuR5wLk)
	[(1181) Use Clojure to build an API - YouTube](https://www.youtube.com/watch?v=e7BTRR0VBsQ)
	[Coast on Clojure](https://coast.swlkr.com/)
	[(1134) Create a password manager with Clojure using Babashka, sqlite, honeysql and stash - YouTube](https://www.youtube.com/watch?v=jm0RXmyjRJ8)
	oku: 2017 ClojureNYC – Datomic, and the failures of REST, hypermedia and ORM
	[Functional effect and streaming systems in Clojure - Léo Noel - reClojure 2021 - YouTube](https://www.youtube.com/watch?v=tV-DoiGdUIo)
	[6 types of information systems | Dustin Getz](https://typeshare.co/dustingetz/posts/6-types-of-information-systems)
	debug clj:
		[AppsFlyer/mate-clj: Clojure library for debugging core functions](https://github.com/AppsFlyer/mate-clj)
		[(748) Unleash the Power of the REPL - Dana Borinski - YouTube](https://www.youtube.com/watch?v=oLvwbDUXGsc)
	[(747) How to work with files in Clojure - YouTube](https://www.youtube.com/watch?v=Kbhe8kFEwlU)
	[holyjak/fulcro-intro-wshop: Introduction to Fulcro workshop held during re:Clojure 2021](https://github.com/holyjak/fulcro-intro-wshop)
	[(739) clojureD 2020: "Fun with JSON" by Malcolm Sparks - YouTube](https://www.youtube.com/watch?v=gMYQ1vDy7d0)
	[CLJS: Hidden Google Closure Library gems - Questions & Help / General Questions - ClojureVerse](https://clojureverse.org/t/cljs-hidden-google-closure-library-gems/2321/3)
	[Introducing shadow-cljs Inspect - Projects / shadow-cljs - ClojureVerse](https://clojureverse.org/t/introducing-shadow-cljs-inspect/5012)
	[(733) First 6 years of a life of Clojure project – Jarppe Länsiö - YouTube](https://www.youtube.com/watch?v=WtdegIqQbrg&t=1209s)
	[(733) Apropos Clojure #10 - shadow-cljs - YouTube](https://www.youtube.com/watch?v=Ow4Qdw25CEA)
	vim-iced clojure eklentisi 
		[vim-iced](https://liquidz.github.io/vim-iced/#installation)
		nxt
			[liquidz/vim-iced: Clojure Interactive Development Environment for Vim8/Neovim](https://github.com/liquidz/vim-iced)
			debugger
			browsing tapped values in threading macros
	[(729) clojureD 2021: "A Trick of the Tool" by Alex Miller - YouTube](https://www.youtube.com/watch?v=BTAx-gFz6Ks)
	[Clojure Workflow Reloaded](https://www.cognitect.com/blog/2013/06/04/clojure-workflow-reloaded)
	[greglook/puget: Canonical Colorizing Clojure Printer](https://github.com/greglook/puget)
	[(724) Building a RESTful Web API in Clojure - a new approach - Malcolm Sparks - YouTube](https://www.youtube.com/watch?v=JWa4NhjWNHQ)
	[(727) clojureD 2020: "Writing maintainable Clojure" by Erik Assum - YouTube](https://www.youtube.com/watch?v=Tq7r97G4b7Y&t=1492s)
	[(727) clojureD 2021: "Your own fast, native Clojure scripting CLI with GraalVM and SCI" by Michiel Borkent - YouTube](https://www.youtube.com/watch?v=L2LAaQBVvxM)
	[inclojure-org/clojure-by-example: An introduction to Clojure, for programmers who are new to Clojure.](https://github.com/inclojure-org/clojure-by-example)
	plan - geliştirilecek örnek clojure uygulamaları  <url:file:///~/projects/myrepo/work/work.otl#r=g12358>
	[PEZ/rich4clojure: Practice Clojure using Interactive Programming in your editor](https://github.com/PEZ/rich4clojure)
	[threatgrid/asami: A graph store for Clojure and ClojureScript](https://github.com/threatgrid/asami)
	[(523) Clojure inline tests: example-driven, executable documentation, powered by metadata - YouTube](https://www.youtube.com/watch?v=orFYFwiG1dM)
	[ertugrulcetin/racing-game-cljs: A 3D racing game built with ClojureScript, React and ThreeJS](https://github.com/ertugrulcetin/racing-game-cljs)
	[borkdude/nbb: Ad-hoc CLJS scripting on Node.js.](https://github.com/borkdude/nbb)
	[(1185) Re-usable GUI Components with Re-frame and Atomic Design - Mark Nutter - YouTube](https://www.youtube.com/watch?v=JCY_cHzklRs)
	[Max Datom - Interactive Datomic Tutorial](https://max-datom.com/)
	[(1201) babashka 0.3.1 new features: bb.edn + invoke any function from cmd line - YouTube](https://www.youtube.com/watch?v=_zr1dicJs-E)
		[(1201) Babashka tasks (by Michiel Borkent) - YouTube](https://www.youtube.com/watch?v=u5ECoR7KT1Y)
