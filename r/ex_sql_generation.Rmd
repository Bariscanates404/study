---
title: "Example: SQL Generation"
date: '`r strftime(Sys.time(), "%Y-%m-%dT%H:%M:%S+03:00")`'
draft: false
description: ""
tags:
categories: examples r sql
type: post
url:
author: "Mert Nuhoglu"
output: rmarkdown::html_document
blog: mertnuhoglu.com
resource_files:
-
---


# Ex01: CREATE TABLE sql generation

Assume that we have the following dataframe that contains the information of the fields of some database tables.

```{r}
library(dplyr, warn.conflicts = F)
dfl = tibble::tribble(
  ~data_field_aid, ~data_field_name,   ~type,     ~pk_fk, ~data_entity_aid, ~entity_name,
               1L,     "vehicle_id",  "TEXT",  "NOT_KEY",               1L,    "Vehicle",
               2L,   "vehicle_type",  "TEXT",  "NOT_KEY",               1L,    "Vehicle"
  )
dfl
```

Now, we need to loop over each table name and generate `CREATE TABLE` sql statements. We need to loop over each `data_entity_aid` to do this.

``` r
dfl = tibble::tribble(
  ~data_field_aid, ~data_field_name,   ~type,     ~pk_fk, ~data_entity_aid, ~entity_name,
               1L,     "vehicle_id",  "TEXT",  "NOT_KEY",               1L,    "Vehicle",
               2L,   "vehicle_type",  "TEXT",  "NOT_KEY",               1L,    "Vehicle"
  )
ids = dplyr::distinct(dfl, data_entity_aid)$data_entity_aid
for (deid in ids) {
  fd = dplyr::filter(dfl, data_entity_aid == deid)
  table_name = unique(fd$entity_name)
  nonpks = dplyr::filter(fd, pk_fk != "PK")
  pks = dplyr::filter(fd, pk_fk == "PK")
  yumltordbschema::create_table_sql_template( 
    table_name, nonpks$data_field_name, nonpks$type, pks$data_field_name )
  #> [1] "CREATE TABLE Vehicle (vehicle_id TEXT,vehicle_type TEXT);"
}
```

Definition of `create_table_sql_template()` is here:

``` r
create_table_sql_template = function( table_name, columns, types, pks ) {
  # usage:
  # template = create_table_sql_template( "t_c_bonitet_bali", names(cbb) )
  # example output:
  # "CREATE TABLE Vehicle ( vehicle_id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, vehicle_type TEXT)"
  template_pk = "%s BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY"
  pk_sql = sprintf(template_pk, pks)
  template_column = "%s %s"
  column_sql = pk_sql %>%
    c( sprintf(template_column, columns, types) )
  column_names = column_sql %>% paste(collapse=",")
  template = "CREATE TABLE %s (%s);"
  result = sprintf( template, table_name, column_names)
  return(result)
}
```

## Why Can't We Use `apply` instead of `for` loop?

In order to use `apply()`, we first need to wrap the body of `for` loop inside a function:

``` r
create_sql = function(fd) {
  table_name = unique(fd$entity_name)
  nonpks = dplyr::filter(fd, pk_fk != "PK")
  pks = dplyr::filter(fd, pk_fk == "PK")
  yumltordbschema::create_table_sql_template( 
    table_name, nonpks$data_field_name, nonpks$type, pks$data_field_name )
}
```

Now, we could have called the function like that:

``` r
apply(dfl, MARGIN = 1, create_sql)
```

But this will not work as expected, because in the above `for` loop we loop per each distinct `data_entity_aid`:

``` r
ids = dplyr::distinct(dfl, data_entity_aid)$data_entity_aid
for (deid in ids) {
  fd = dplyr::filter(dfl, data_entity_aid == deid)
  ...
}
```

In order to use `apply()` function, we need to ensure that each row of `dfl` contains a distinct `data_entity_aid`.
